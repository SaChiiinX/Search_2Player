;; ========================================
;;   CMPU-365, Fall 2023
;;   Asmt. 1
;;   SOLUTIONS!!!
;; ========================================
;;   FILE: gen-search-starter.lisp
;; ========================================
;;   General tree-search algorithm.  Special cases
;;   include breadth-first and depth-first search.

;;  Load the "basic-defns" file that defines the PROBLEM and NODE
;;  data structures and some related low-level functions.

(load "basic-defns" :verbose nil)

;;   CYCLE? 
;; -------------------------------------------------------------
;;  INPUTS:  STATE, a problem state
;;           NODE, a search node
;;           STATE-EQ-FUNC, a function that determines whether
;;             two states are equal
;;  OUTPUT:  T if the given STATE is the same as the state of
;;    the given NODE or the state of any of NODE's ancestors.
;;    Uses STATE-EQ-FUNC to determine whether two states are equal.
;;    Otherwise returns NIL. 
;;    NOTE:  If NODE is NIL it returns NIL.

(defun cycle? (state node state-eq-func)
  (and node
       (or (funcall state-eq-func state (node-state node))
	   (cycle? state (node-parent node) state-eq-func))))

;;  MAKE-ROOT-NODE 
;; ---------------------------------------
;;  INPUT:  PROB, a search problem
;;  OUTPUT:  A search NODE that will be the ROOT NODE of a
;;           brand new search tree.

(defun make-root-node (prob)
  (make-node :state (search-problem-init-state prob)))

;;  EXPAND 
;; ---------------------------------
;;  INPUTS:  NODE, a search node
;;           ACTS, a list of actions
;;           ST-EQ-FUNC, a function for testing whether two
;;              states are equal
;;  OUTPUT:  A list of child nodes obtained by applying the
;;           given list of actions to NODE's state.  However, it
;;           does *NOT* include child nodes whose states already
;;           appear on the path from the root node to NODE.
;;           (Use CYCLE? to determine this.)

(defun expand (node acts st-eq-func)

  (let (;; Some local variables for convenience
	(curr-state (node-state node))
	(curr-depth (node-depth node)))
    (labels (;;  EXPAND-ACC
	     ;; ------------------------------
	     ;;  INPUTS:  ACTIES, list of actions (lisp functions)
	     ;;           CHILDREN-ACC, accumulated child nodes
	     ;;  OUTPUT:  When called with CHILDREN-ACC = NIL, the output
	     ;;           is the list of child nodes generated by applying
	     ;;           the actions in ACTIES to the current state, 
	     ;;           ignoring child-states that create cycles.
	     (expand-acc (acties children-acc)
	       (cond
		;; Case 1:  All done
		((null acties)
		 ;; Return the accumulated child nodes
		 children-acc)
		;; Case 2:  At least one more action to do
		(t
		 (let ((child-state (funcall (first acties) curr-state)))
		   (cond
		    ;; Case 2a:  Gonna accumulate a new child node!
		    ((and child-state 
			  (not (cycle? child-state node st-eq-func)))
		     (expand-acc (rest acties)
				 (cons (make-node :state child-state
						  :parent node
						  :action (first acties)
						  :depth (1+ curr-depth))
				       children-acc)))
		    ;; Case 2b:  Not gonna accumulate a new child node!
		    (t
		     (expand-acc (rest acties) children-acc))))))))
      ;; Body of LABELS
      (expand-acc acts nil))))

;; --------------------------------------------------------
;;  GEN-SEARCH-GUTS
;; ---------------------------------------------------------------
;;  INPUTS: PROBLEM, a search problem
;;          QUEUE-FN, a queuing function (used to insert newly
;;            created nodes into the search queue).  The queuing
;;            function determines which kind of search we're doing.
;;          REZZY, a RESULTS struct
;;  OUTPUT: The RESULTS struct, with its fields updated to include
;;          info about the search (e.g., num nodes explored; the goal
;;          node, if found; and timing information).
;; ---------------------------------------------------------------
;;  This function performs the indicated search problem using
;;  the search strategy determined by QUEUE-FN.

(defun gen-search-guts (problem queue-fn rezzy)

  (let (;; Some local variables for convenience      
        (gt-func (search-problem-goal-test-func problem))
        (st-eq-func (search-problem-state-eq-func problem))
        (acts (search-problem-actions problem)))
    
    (labels
	;; GEN-REC:  A RECURSIVE HELPER FUNCTION
	;;   QUEUE:  Used to hold the "frontier" of as-yet-unexplored" nodes
	((gen-rec (queue)
	   (cond
	    ;; Case 1:  QUEUE is empty
	    ((null queue)
	     ;; Search failed to find a goal
	     rezzy)
	    ;; Case 2:  First node in queue is a goal!
	    ((funcall gt-func (node-state (first queue)))
	     ;; Tell RESULTS about the goal
	     (setf (results-goal-node rezzy) (first queue))
	     ;; return REZZY
	     rezzy)
	    ;; Case 3:  First node is not a goal
	    (t
	     ;; Expand it, update num-nodes generated, and update queue
	     (let ((new-nodes (expand (first queue) acts st-eq-func)))
	       (incf (results-num-nodes rezzy) (length new-nodes))
	       (gen-rec (funcall queue-fn (rest queue) new-nodes)))))))
	
      ;; BODY OF LABELS
      ;;   Call GEN-REC with the initial search queue
      (gen-rec (list (make-root-node problem))))))

